data class Hero(
    val name: String,
    val age: Int,
    val gender: Gender?
)
enum class Gender {MALE, FEMALE }

fun main(args: Array<String>) {
    val heroes = listOf(
    Hero("The Captain", 60, MALE),
    Hero("Frenchy", 42, MALE), 
    Hero("The Kid", 9, null), 
    Hero("Lady Lauren", 29, FEMALE), 
    Hero("First Mate", 29, MALE), 
    Hero("Sir Stephen", 37, MALE))

	  //check for the first, last, firstOrNull, lastOrNull operations.
    heroes.last().name    //-- Sir Stephen
    heroes.first().name   //-- The Captain
    heroes.firstOrNull{it.age == 30}?.name  //-- null [No age == 30]
    heroes.first{it.age == 30}.name         // NoSuchElementException
    // map. distinct
    heroes.map{it.age}        // 60,42,9,29,29,37
    heroes.map{it.age}.distinct()        // 60,42,9,29,37
    heroes.map{it.age}.distinct().size        // 5
    // Filter
    heroes.filter{it.age<30}.size        // 3
    // partition
    val(youngest, oldest) = heroes.partition{it.age < 30}
    oldest.size               // 3
    //maxBy, minBy
    // compare by property or other parameters
    heroes.maxBy{it.age}?.name    // The Captain
    heroes.minBy{it.age}?.name    // The Kid
    
    // all, any
    heroes.all{it.age < 50}       // false (not all age is < 50)
    heroes.any{it.gender == MALE}   // true
    
    // Mapping by property
    val mapByAge: Map<Int, List<Hero>> = heroes.groupBy { it.age }
    // Create another list based on mapping criteria.
    // new list based on age. 1 entry based on 60, 42, 9, 37. Another group with 2 entries for age 29.
    val (age, group) = mapByAge.maxBy { (_, group) -> group.size}!!
    // maxBy got the age=29 entry, having 2 entries
    println(age)    // 29
    
    
}
